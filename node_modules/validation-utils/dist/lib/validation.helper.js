"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateInheritsFrom = exports.validateInstanceOf = exports.validateArray = exports.validateObject = exports.validateNotNilProperties = exports.validateHasProperties = exports.validateFunction = exports.validateFalsy = exports.validateTruthy = exports.validateBooleanFalse = exports.validateBoolean = exports.validateBooleanNonStrict = exports.validateDate = exports.validateBooleanTrue = exports.validateString = exports.validateNegativeNumber = exports.validateSomeNotNil = exports.validateOneOf = exports.validateEqual = exports.validateGreaterThan = exports.validateLessThan = exports.validatePositiveNumber = exports.validateNumber = exports.validateNotEmpty = exports.validateNil = exports.validateNotNil = void 0;
const ValidationError_1 = require("./ValidationError");
const zoology_1 = require("zoology");
/**
 * Checks value not to be null or undefined
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {*} validatedObject
 */
function validateNotNil(validatedObject, errorText) {
    if (zoology_1.isNil(validatedObject)) {
        throw new ValidationError_1.default(errorText || 'Validated object is null or undefined');
    }
    return validatedObject;
}
exports.validateNotNil = validateNotNil;
/**
 * Checks value to be null or undefined
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {*} validatedObject
 */
function validateNil(validatedObject, errorText) {
    if (!zoology_1.isNil(validatedObject)) {
        throw new ValidationError_1.default(errorText || 'Validated object is not null or undefined');
    }
    return validatedObject;
}
exports.validateNil = validateNil;
/**
 * Checks value not to be an empty Object, String or Array
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {*} validatedObject
 */
function validateNotEmpty(validatedObject, errorText) {
    if (zoology_1.isEmpty(validatedObject)) {
        throw new ValidationError_1.default(errorText || 'Validated object is empty');
    }
    return validatedObject;
}
exports.validateNotEmpty = validateNotEmpty;
/**
 * Checks value to be a number
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {number} validatedObject
 */
function validateNumber(validatedObject, errorText) {
    if (!zoology_1.isFinite(validatedObject)) {
        throw new ValidationError_1.default(errorText || 'Validated object is not a number');
    }
    return validatedObject;
}
exports.validateNumber = validateNumber;
/**
 * Checks value to be a number that is larger than 0
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {number} validatedObject
 */
function validatePositiveNumber(validatedObject, errorText) {
    validateNumber(validatedObject);
    if (validatedObject <= 0) {
        throw new ValidationError_1.default(errorText || 'Validated number is not positive');
    }
    return validatedObject;
}
exports.validatePositiveNumber = validatePositiveNumber;
/**
 * Checks value to be a number that is less than the specified number
 * @param {*} validatedObject
 * @param {number} threshold - if validated number is equal or larger than this, throw an error
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {number} validatedObject
 */
function validateLessThan(validatedObject, threshold, errorText) {
    validateNumber(validatedObject);
    validateNumber(threshold, 'Threshold is not a number');
    if (validatedObject >= threshold) {
        throw new ValidationError_1.default(errorText || `Validated number ${validatedObject} is not less than the threshold ${threshold}`);
    }
    return validatedObject;
}
exports.validateLessThan = validateLessThan;
/**
 * Checks value to be a number that is greater than specified number
 * @param {*} validatedObject
 * @param {number} threshold - if validated number is equal or less than this, throw an error
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {number} validatedObject
 */
function validateGreaterThan(validatedObject, threshold, errorText) {
    validateNumber(validatedObject);
    validateNumber(threshold, 'Threshold is not a number');
    if (validatedObject <= threshold) {
        throw new ValidationError_1.default(errorText || `Validated number ${validatedObject} is not greater than the threshold ${threshold}`);
    }
    return validatedObject;
}
exports.validateGreaterThan = validateGreaterThan;
/**
 * Checks value to equal specified entity (=== comparison)
 * @param {*} validatedEntity
 * @param {*} expectedEqualTo - if validated entity is not equal to this, throw an error
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {number} validatedObject
 */
function validateEqual(validatedEntity, expectedEqualTo, errorText) {
    if (validatedEntity !== expectedEqualTo) {
        throw new ValidationError_1.default(errorText || `Validated entity ${validatedEntity} is not equal to ${expectedEqualTo}`);
    }
    return validatedEntity;
}
exports.validateEqual = validateEqual;
/**
 * Checks value to be included among specified entities (indexOf !== -1 comparison)
 * @param {*} validatedEntity
 * @param {*} expectedOneOfEntities - if validated entity is not equal to one of these, throw an error
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {number} validatedObject
 */
function validateOneOf(validatedEntity, expectedOneOfEntities, errorText) {
    const index = expectedOneOfEntities.indexOf(validatedEntity);
    if (index === -1) {
        throw new ValidationError_1.default(errorText || `Validated entity ${validatedEntity} is not one of ${expectedOneOfEntities}`);
    }
    return validatedEntity;
}
exports.validateOneOf = validateOneOf;
function validateSomeNotNil(validatedEntities, errorText) {
    const someAreNotNil = validatedEntities.some((entity) => !zoology_1.isNil(entity));
    if (!someAreNotNil) {
        throw new ValidationError_1.default(errorText || 'All of validated values are nil');
    }
    return validatedEntities;
}
exports.validateSomeNotNil = validateSomeNotNil;
/**
 * Checks value to be a number that is less than 0
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {number} validatedObject
 */
function validateNegativeNumber(validatedObject, errorText) {
    validateNumber(validatedObject);
    if (validatedObject >= 0) {
        throw new ValidationError_1.default(errorText || 'Validated number is not negative');
    }
    return validatedObject;
}
exports.validateNegativeNumber = validateNegativeNumber;
/**
 * Checks value to be a string
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {String} validatedObject
 */
function validateString(validatedObject, errorText) {
    if (!zoology_1.isString(validatedObject)) {
        throw new ValidationError_1.default(errorText || 'Validated object is not a string');
    }
    return validatedObject;
}
exports.validateString = validateString;
/**
 * Checks value to be a True boolean
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {boolean} validatedObject
 */
function validateBooleanTrue(validatedObject, errorText) {
    if (!zoology_1.isBoolean(validatedObject) || !validatedObject) {
        throw new ValidationError_1.default(errorText || 'Validated object is not True');
    }
    return validatedObject;
}
exports.validateBooleanTrue = validateBooleanTrue;
/**
 * Checks value to be an instance of Date
 * @param {*} validatedEntity
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {boolean} validatedObject
 */
function validateDate(validatedEntity, errorText) {
    if (!zoology_1.isDate(validatedEntity)) {
        throw new ValidationError_1.default(errorText || 'Validated object is not Date');
    }
    return validatedEntity;
}
exports.validateDate = validateDate;
/**
 * Checks value to be a boolean or a (case-insensitive) 'true' or 'false' string
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {*} validatedObject
 */
function validateBooleanNonStrict(validatedObject, errorText) {
    if (!zoology_1.isBoolean(validatedObject)) {
        if (!zoology_1.isString(validatedObject) ||
            (validatedObject.toLowerCase() !== 'false' && validatedObject.toLowerCase() !== 'true')) {
            throw new ValidationError_1.default(errorText || 'Validated object is not Boolean');
        }
    }
    return validatedObject;
}
exports.validateBooleanNonStrict = validateBooleanNonStrict;
/**
 * Checks value to be a boolean
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {*} validatedObject
 */
function validateBoolean(validatedObject, errorText) {
    if (!zoology_1.isBoolean(validatedObject)) {
        throw new ValidationError_1.default(errorText || 'Validated object is not Boolean');
    }
    return validatedObject;
}
exports.validateBoolean = validateBoolean;
/**
 * Checks value to be a False boolean
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {boolean} validatedObject
 */
function validateBooleanFalse(validatedObject, errorText) {
    if (!zoology_1.isBoolean(validatedObject) || validatedObject) {
        throw new ValidationError_1.default(errorText || 'Validated object is not False');
    }
    return validatedObject;
}
exports.validateBooleanFalse = validateBooleanFalse;
/**
 * Checks value to be a truthy entity
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {*} validatedObject
 */
function validateTruthy(validatedObject, errorText) {
    if (!validatedObject) {
        throw new ValidationError_1.default(errorText || 'Validated object is not truthy');
    }
    return validatedObject;
}
exports.validateTruthy = validateTruthy;
/**
 * Checks value to be a falsy entity
 * @param {*} validatedObject
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {*} validatedObject
 */
function validateFalsy(validatedObject, errorText) {
    if (validatedObject) {
        throw new ValidationError_1.default(errorText || 'Validated object is not falsy');
    }
    return validatedObject;
}
exports.validateFalsy = validateFalsy;
/**
 * Checks value to be a function
 * @param {*} validatedEntity
 * @param {String} [errorText] - message for error thrown if validation fails
 * @returns {*} validatedEntity
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function validateFunction(validatedEntity, errorText) {
    if (!zoology_1.isFunction(validatedEntity)) {
        throw new ValidationError_1.default(errorText || 'Validated entity is not a function');
    }
    return validatedEntity;
}
exports.validateFunction = validateFunction;
/**
 * Checks object to have at least a given set of properties defined
 * @param {*} validatedObject
 * @param {String[]} validatedProperties - names of properties which existence should be checked
 * @param {string} [errorMessage] - error message prefixed to the list of undefined properties
 * @returns {*} validatedObject
 */
function validateHasProperties(validatedObject, validatedProperties, errorMessage) {
    validateNotNil(validatedObject);
    const undefinedProperties = validatedProperties.filter((property) => {
        return !Object.prototype.hasOwnProperty.call(validatedObject, property);
    });
    if (undefinedProperties.length > 0) {
        throw new ValidationError_1.default(`${errorMessage !== null && errorMessage !== void 0 ? errorMessage : "Validated object doesn't have properties: "}${undefinedProperties}`);
    }
    return validatedObject;
}
exports.validateHasProperties = validateHasProperties;
/**
 * Checks object to have at least a given set of not nil properties
 * @param {*} validatedObject
 * @param {String[]} validatedProperties - names of properties which existence should be checked
 * @param {string} [errorMessage] - error message prefixed to the list of nil properties
 * @returns {*} validatedObject
 */
function validateNotNilProperties(validatedObject, validatedProperties, errorMessage) {
    validateNotNil(validatedObject);
    const nilProperties = validatedProperties.filter((property) => {
        return zoology_1.isNil(validatedObject[property]);
    });
    if (nilProperties.length > 0) {
        throw new ValidationError_1.default(`${errorMessage !== null && errorMessage !== void 0 ? errorMessage : 'Validated object has nil properties: '}${nilProperties}`);
    }
    return validatedObject;
}
exports.validateNotNilProperties = validateNotNilProperties;
/**
 * Checks value to be an object
 * @param validatedObject
 * @param {string} [errorText] - message for error thrown if validation fails
 * @returns {Object} validatedObject
 */
function validateObject(validatedObject, errorText) {
    if (!zoology_1.isObject(validatedObject)) {
        throw new ValidationError_1.default(errorText || 'Validated object is not an object');
    }
    return validatedObject;
}
exports.validateObject = validateObject;
/**
 * Checks value to be an object
 * @param validatedObject
 * @param {string} [errorText] - message for error thrown if validation fails
 * @returns {Object} validatedObject
 */
function validateArray(validatedObject, errorText) {
    if (!Array.isArray(validatedObject)) {
        throw new ValidationError_1.default(errorText || 'Validated entity is not an array');
    }
    return validatedObject;
}
exports.validateArray = validateArray;
/**
 * Checks value to be an instance of a given class
 * @param validatedObject
 * @param {class} expectedClass
 * @param {string} [errorText] - message for error thrown if validation fails
 * @returns {Object} validatedObject
 */
function validateInstanceOf(validatedObject, expectedClass, errorText) {
    if (!(validatedObject instanceof expectedClass)) {
        throw new ValidationError_1.default(errorText || `Validated object is not an instance of ${expectedClass.name}`);
    }
    return validatedObject;
}
exports.validateInstanceOf = validateInstanceOf;
/**
 * Checks value to inherit from a given class or to be that class
 * @param validatedClass
 * @param {class} expectedParentClass
 * @param {string} [errorText] - message for error thrown if validation fails
 * @returns {Object} validatedObject
 */
function validateInheritsFrom(validatedClass, expectedParentClass, errorText) {
    if (
    //fail-fast if it is nil
    !validatedClass ||
        //lenient check whether class directly or indirectly inherits from expected class
        (!(validatedClass.prototype instanceof expectedParentClass) && validatedClass !== expectedParentClass)) {
        throw new ValidationError_1.default(errorText || `Validated class does not inherit from ${expectedParentClass.name}`);
    }
    return validatedClass;
}
exports.validateInheritsFrom = validateInheritsFrom;
